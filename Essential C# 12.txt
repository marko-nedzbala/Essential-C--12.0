
https://github.com/IntelliTect/EssentialCSharp



Chapter01
Introducing C#

Chapter02
Data Types

String Interpolation
"""example text""" string literal

the number of $'s means you need the same amount of corresponding {}'s
// example
Console.WriteLine($$""" Hello, I am {{{firstName}}} """);

String formatting
string.Format("{placeHolder,spacing:formatCode}");
string.Format("{0,20:C2}");

$"{variableName,spacing:formatCode}"
$"{price,20:C2}"

decimal price = 1_456.78M;
Console.WriteLine($"{{ {price:C2} }}");



Chapter03
More with Data Types

string? x = null;
int? length = x?.Length;
// null length, will return nothing
System.Console.WriteLine($"Length: {length}");

// now has a value, will return a number of 9
x = "Some text";
length = x?.Length;
System.Console.WriteLine($"New Length: {length}");

// assign anohter null value to the same variable
// null length, will return nothing
int? y = null;
length = y;
System.Console.WriteLine($"Yet another Length: {length}");

nullable reference types: reference types could be non-nullable as well, brings reference types on par with value types, reference type declarations can occur with or without nullable modifier. In C# 8.0 declaring a variable without the nullable modifier implies it is not nullable
due to backwards compatibility, reference type nullability is not enabled by default on exisitng projects
to enable it:
1.) #nullable directive: #nullable enable
2.) *.csproj: <Nullable>enable</Nullable>
3.) via command line: $ dotnet build /p:Nullable=enable

basically in C# 8.0 and onwards, declaring a variable without dataType?, does not allow the variable to be null

the settings for <Nullable>disable</Nullable>
// therefore this is allowed
string x = null;
if (x is null)
{
    System.Console.WriteLine("I am allowed to be null, because of the setting");
}

Tuples
the most confusing things about tuples, is the many different syntaxes invovled in assigning them

base example
(string country, string capital, dobule gdpPerCapita) = ("Slovenia", "Ljubljana", 123.456);

// 1.) assign a tuple to individually declared variables
(string country, string capital, double gdpPerCapita) = ("Slovenia", "Ljubljana", 123.456);
"{capital} is the capital of {country} with a GDP of: {gdpPerCapita}"

// 2.) assign a tuple to individually declared variables that are pre-declared
string country;
string capital;
double gdpPerCapita;
(country, capital, gdpPerCapita) = ("Slovenia", "Ljubljana", 123.456);
System.Console.WriteLine($"{capital} is the capital of {country} with a GDP of: ${gdpPerCapita}");

// 3.) assign a tuple to individually declared and implicity typed variables
(var country, var capital, var gdpPerCapita) = ("Slovenia", "Ljubljana", 123.456);
System.Console.WriteLine($"{capital} is the capital of {country} with a GDP of: ${gdpPerCapita}");

// 4.) assign a tuple to individually declared variables that are implicitly typed with a distributive syntax
var (country, capital, gdpPerCapita) = ("Slovenia", "Ljubljana", 123.546);
System.Console.WriteLine($"{capital} is the capital of {country} with a GDP of: ${gdpPerCapita}");

// 5.) declare a name item tuple and assign it tuple values, then access the tuple items by name
(string Name, string Capital, double GdpPerCapita) countryInfo = ("Slovenia", "Ljubljana", 123.456);
System.Console.WriteLine($"{countryInfo.Capital} is the capital {countryInfo.Name} with a GDP of: {countryInfo.GdpPerCapita}");

// 6.) assign a named item tuple to a single implicitly type variable that is implicitly typed, and then access the tuple items by name
var countryInfo = (Name: "Slovenia", Capital: "Ljubljana", GdpPerCapita: 123.456);
System.Console.WriteLine($"{countryInfo.Capital} is the capital of {countryInfo.Name} with a GDP of: ${countryInfo.GdpPerCapita}");

// 7.) assign an unnamed tuple to a single implicitly typed variablem then access the tuple elements by their item-number property
var countryInfo = ("Slovenia", "Ljubljana", 123.456);
System.Console.WriteLine($"{countryInfo.Item2} is the capital of {countryInfo.Item1} with a GDP of: ${countryInfo.Item3}");

// 8.) assign a named item tuple to a single implicitly typed variable, then access the tuple items by their iterm-number property
var countryInfo = (Name: "Slovenia", Capital: "Ljubljana", GdpPerCapita: 123.456);
System.Console.WriteLine($"{countryInfo.Capital} is the capital of {countryInfo.Name} with a GDP of: ${countryInfo.GdpPerCapita}");

// 9.) discard portions of the tuple with underscores
(string name, _, double gdpPerCapita) = ("Slovenia", "Ljubljana", 123.456);

// 10.) tuple element names can be inferred from variable and property names
string country = "Slovenia";
string capital = "Ljubljana";
double gdpPerCapita = 123.456;
var countryInfo = (country, capital, gdpPerCapita);
System.Console.WriteLine($"{countryInfo.capital} is the capital of {countryInfo.country} with a GDP of: ${countryInfo.gdpPerCapita}");


Chapter04
Operators and Control Flow

associativity: determines how similar operators are parenthesized
precedence: determines how dissimilar operators are parenthesized



Chapter05
Parameters and Methods

Left off page 252












































